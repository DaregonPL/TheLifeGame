import shutil
import os
lfc = b'PK\x03\x04\x14\x00\x00\x00\x08\x00\x93F\x84X\xc2\xa1\xefK\n\x00\x00\x00v\x00\x00\x00\x0b\x00\x00\x00blank10.lfc30\x80\x01^.\x03\xba\xb1\x01PK\x03\x04\x14\x00\x00\x00\x08\x00\xe1\xb8\x83XbT\xc6j"\x00\x00\x00\xb6\x01\x00\x00\x07\x00\x00\x00pin.lfc30\xc0\x04\xbc\\X\x04\xa9*j\x08\x02\xe8\xa2\x86\x86H\xc2\x04D\xb1\x9b0(E\r\xd1\x00\xe9\xa2\x98\x00\x00PK\x01\x02\x14\x00\x14\x00\x00\x00\x08\x00\x93F\x84X\xc2\xa1\xefK\n\x00\x00\x00v\x00\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\x00\x00\x00\x00blank10.lfcPK\x01\x02\x14\x00\x14\x00\x00\x00\x08\x00\xe1\xb8\x83XbT\xc6j"\x00\x00\x00\xb6\x01\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x813\x00\x00\x00pin.lfcPK\x05\x06\x00\x00\x00\x00\x02\x00\x02\x00n\x00\x00\x00z\x00\x00\x00\x00\x00'
code = b'from random import randint\r\nimport time\r\nimport glob\r\nimport os\r\nimport copy\r\n\r\n\r\nclass TheLife():\r\n    glider = [(2, 0), (2, 1), (2, 2), (1, 2), (0, 1)]\r\n    speedlist = [0.5, 0.75, 1, 1.5, 2, 5, 10, 20]\r\n    bg = \'\xe2\x97\xa6\'\r\n    maxfill = 0.75\r\n    \r\n    def __init__(self):\r\n        self.height, self.width = 10, 10\r\n        self.cls = False\r\n        self.speed = 5\r\n        self.allow_repeat = False\r\n\r\n    def setup(self, **kw):\r\n        for n, v in kw.items():\r\n            if n == \'height\':\r\n                self.height = v\r\n            elif n == \'width\':\r\n                self.width = v\r\n\r\n    def create_map(self):\r\n        self.map = Map(self.height, self.width)\r\n\r\n    def run(self):\r\n        print(\'TheLifeGame CR: VovLer Games;\\nSettings:\')\r\n        print(f\' x:{self.width};\\n y:{self.height}\')\r\n        print(f\' speed{self.speed};\\n cls:{self.cls};\\n\' +\r\n              f\'allow_repeat: {self.allow_repeat}\')\r\n        self.set_marks()\r\n        print(\'Limit of generations: (do not type anything to skip)\')\r\n        limit = input()\r\n        limit = int(limit) if limit.isdigit() else None\r\n        self.generate(limit, self.allow_repeat)\r\n        print(\'Game Over! Results:\')\r\n        print(self.map.statistic)\r\n        print(f\'Generations: {len(self.map.frames)}\')\r\n        input()\r\n        self.run()\r\n\r\n    def generate(self, limit=None, repeat_ok=True):\r\n        framenum = 0\r\n        delay = 0.5 / self.speed\r\n        while 1:\r\n            framenum += 1\r\n            os.system(\'cls\') if self.cls else print(\'\\n\\n\\n\')\r\n            self.map.generate()\r\n            [print(\' \'.join(x).replace(\'\xe2\x96\xa1\', self.bg)) for x in\r\n                     self.map.lastframe()]\r\n            if limit and framenum == limit:\r\n                break\r\n            elif not repeat_ok and self.map.lastframe() in self.map.frames:\r\n                break\r\n            self.map.save() if not repeat_ok else None\r\n            time.sleep(delay)\r\n\r\n    def set_marks(self):\r\n        sepcol = \' \' * len(str(self.width - 1))\r\n        maxrow = len(str(len(self.map.lastframe()) - 1))\r\n        while True:\r\n            print(\'\\n= Setup: Enter {row};{column} to fill\' +\r\n                  \' a cell or nothin if you\\\'re done =\')\r\n            print(\'commands:\')\r\n            print(\'"glider" - create glider\')\r\n            print(\'"random" - fill random cells\')\r\n            print(\'"cls" - enable/disable cleaning console\')\r\n            print(\'"speed" - change speed\')\r\n            print(\'"bg" - switch background\')\r\n            print(\'"allow_repeat" - allow/prohibit repeating frames\')\r\n            print(\'"load" - load confifuration\')\r\n            print(\'\\nSettings:\')\r\n            print(f\' speed: {self.speed}x;\\n cls: {self.cls};\\n\' +\r\n                  f\' allow_repeat: {self.allow_repeat};\\n bg: "{self.bg}"\')\r\n            print(\'\')\r\n            field = self.apply_cord(self.map.lastframe())\r\n            for r in field:\r\n                r[0] = r[0] + \' \' * (maxrow - len(r[0]))\r\n            cols = \'\'\r\n            for x in field.pop(0):\r\n                if \' \' not in x:\r\n                    cols += x + \' \' * (len(sepcol) + 1 - len(x))\r\n                else:\r\n                    cols += \' \' * maxrow + sepcol\r\n            print(cols)\r\n            print(\'\\n\'.join([sepcol.join(x) for x in\r\n                             field]))\r\n            x = input()\r\n            if x.split(\';\') and not [x for x in x.split(\';\')\r\n                                     if not x.isdigit()] and \\\r\n                        len(x.split(\';\')) == 2:\r\n                try:\r\n                    if bl(self.map.val(*[int(a) for a in x.split(\';\')])):\r\n                        self.map.pop(*x.split(\';\'))\r\n                    else:\r\n                        self.map.mark(*x.split(\';\'))\r\n                except IndexError:\r\n                    print(f\'Cannot access cell {x.split(";")}\')\r\n                finally:\r\n                    pass\r\n            elif x == \'gen\':\r\n                self.map.generate()\r\n            elif x == \'frames\':\r\n                for x in range(len(self.map.frames)):\r\n                    print(f\'\\n = {x} =\')\r\n                    [print(\' \'.join(x)) for x in self.map.frames[x]]\r\n            elif x == \'glider\':\r\n                [self.map.mark(*x) for x in self.glider]\r\n            elif x == \'random\':\r\n                cells = randint(0, int(self.map.w * self.map.h * self.maxfill))\r\n                for x in range(cells):\r\n                    self.map.mark(randint(0, self.map.h - 1),\r\n                                   randint(0, self.map.w - 1))\r\n            elif x == \'save\':\r\n                self.map.save()\r\n            elif x == \'load\':\r\n                print(\'available:\')\r\n                print(\'\\n\'.join([x for x in glob.glob(\'lfc/*.lfc\')]))\r\n                f = input(\'\\nlfc/___.lfc :\\n>\')\r\n                if os.path.exists(f\'lfc/{f}.lfc\'):\r\n                    with open(f\'lfc/{f}.lfc\') as lfc:\r\n                        data = lfc.read()\r\n                    h = len(data.split(\'\\n\'))\r\n                    w = max([len(x) for x in data.split(\'\\n\')])\r\n                    self.map = Map(h, w)\r\n                    data = data.split(\'\\n\')\r\n                    self.height = h\r\n                    self.width = w\r\n                    self.create_map()\r\n                    for x in range(h):\r\n                        for y in range(len(data[x])):\r\n                            self.map.mark(x, y) if data[x][y] == \'1\' else 0\r\n                    self.run()\r\n                    break\r\n                else:\r\n                    print(\'not found\')\r\n            elif x == \'cls\':\r\n                self.cls = False if self.cls else True\r\n                print(\'CLS:\', self.cls)\r\n            elif x == \'speed\':\r\n                self.speed = self.speedlist[(self.speedlist.index(self.speed)\r\n                                             + 1) % len(self.speedlist)]\r\n                print(\'Speed:\', self.speed)\r\n            elif x == "allow_repeat":\r\n                self.allow_repeat = False if self.allow_repeat else True\r\n            elif x == \'bg\':\r\n                self.bg = \' \' if self.bg != \' \' else \'\xe2\x97\xa6\'\r\n            elif x == \'\':\r\n                break\r\n            else:\r\n                print(\'unexpected input\')\r\n\r\n    def apply_cord(self, matrix):\r\n        mtx = matrix.copy()\r\n        return [[\' \'] + [str(x) for x in range(self.width)]] + \\\r\n               [[str(x)] + mtx[x] for x in range(self.height)]\r\n\r\n\r\nclass Map():\r\n    def __init__(self, height, width):\r\n        self.h, self.w = height, width\r\n        self.field = [[\'\xe2\x96\xa1\' for x in range(width)] for y in range(height)]\r\n        self.frames = []\r\n        self.statistic = {\'Died\': 0, \'Born\': 0}\r\n        self.save()\r\n\r\n    def generate(self):\r\n        stk = FrameStreak(self.field)\r\n        field = self.lastframe()\r\n        cell = stk.next()\r\n        while cell:\r\n            c, n = bl(self.val(*cell)), len([x for x in stk.near()\r\n                                             if bl(self.val(*x))])\r\n            if c:\r\n                if n < 2 or n > 3:\r\n                    field[cell[0]][cell[1]] = \'\xe2\x96\xa1\'\r\n                    self.statistic[\'Died\'] += 1\r\n            else:\r\n                if n == 3:\r\n                    field[cell[0]][cell[1]] = \'\xe2\x96\xa0\'\r\n                    self.statistic[\'Born\'] += 1\r\n            cell = stk.next()\r\n        self.field = copy.deepcopy(field)\r\n\r\n    def mark(self, x, y):\r\n        self.field[int(x)][int(y)] = \'\xe2\x96\xa0\'\r\n\r\n    def pop(self, x, y):\r\n        self.field[int(x)][int(y)] = \'\xe2\x96\xa1\'\r\n\r\n    def save(self):\r\n        self.frames.append(copy.deepcopy(self.field))\r\n\r\n    def val(self, y, x):\r\n        return self.field[y][x]\r\n\r\n    def lastframe(self):\r\n        return copy.deepcopy(self.field)\r\n\r\n\r\nclass FrameStreak():\r\n    def __init__(self, frame):\r\n        self.frame = copy.deepcopy(frame)\r\n        self.x, self.y = -1, 0\r\n        self.height, self.width = len(self.frame), len(self.frame[0])\r\n\r\n    def next(self):\r\n        if self.x + 1 == self.width:\r\n            if self.y + 1 == self.height:\r\n                return None\r\n            else:\r\n                self.x = 0\r\n                self.y += 1\r\n        else:\r\n            self.x += 1\r\n        return (self.y, self.x)\r\n\r\n    def near(self):\r\n        return [((self.y + 1) % self.height, self.x),\r\n                ((self.y + 1) % self.height, (self.x + 1) % self.width),\r\n                ((self.y - 1) % self.height, (self.x + 1) % self.width),\r\n                ((self.y - 1) % self.height, (self.x - 1) % self.width),\r\n                ((self.y + 1) % self.height, (self.x - 1) % self.width),\r\n                (self.y, (self.x + 1) % self.width),\r\n                ((self.y - 1) % self.height, self.x),\r\n                (self.y, (self.x - 1) % self.width)]\r\n\r\n\r\ndef bl(obj):\r\n    return True if obj == \'\xe2\x96\xa0\' else False\r\n\r\n\r\nprint(\'Height: (10 by default)\')\r\nh = input()\r\nprint(\'Width: (10 by default)\')\r\nw = input()\r\nlife = TheLife()\r\nlife.setup(height=int(h)) if h.isdigit() else None\r\nlife.setup(width=int(w)) if w.isdigit() else None\r\nlife.create_map()\r\nlife.run()\r\n'

if not os.path.exists('game.py'):
    with open('game.py', 'wb') as codef:
        codef.write(code)
    print('game installed;')
if not os.path.exists('lfc'):
    with open('LFC.zip', 'wb') as lfcf:
        lfcf.write(lfc)
    shutil.unpack_archive('LFC.zip', 'lfc', 'zip')
    os.remove('LFC.zip')
    print('lfc installed;')
import game
